# src/resources/templates.py

class VMPTemplates:
    """VMP code generation templates"""
    
    @staticmethod
    def get_vmp_header():
        """Get VMP assembly header template"""
        return """; VMP Protected Assembly
; Generated by VMP Transformer
; Protection Level: {protection_level}
; Timestamp: {timestamp}

; Virtual Machine Protection (VMP) Implementation
; This code has been transformed to run on a custom VM interpreter

"""

    @staticmethod
    def get_data_section_template():
        """Get data section template"""
        return """section .data
    ; VMP bytecode segment
    vmp_code_seg: db {code_bytes}
    vmp_code_size: dd {code_size}
    
    ; VMP data segment (variables and runtime data)
    vmp_data_seg: times {data_size} db 0
    
    ; VM state
    vm_ip: dd 0
    vm_opcode_seed: dd 0
    vm_code_seed: dd 0
    
{variable_mappings}
"""

    @staticmethod
    def get_text_section_template():
        """Get text section template"""
        return """section .text
    global _start
    
_start:
    ; Initialize VM
    call vmp_init
    
    ; Execute VM bytecode
    call vmp_interpreter
    
    ; Exit program
    mov eax, 1          ; sys_exit
    xor ebx, ebx        ; exit code 0
    int 0x80

; Include VMP interpreter runtime
%include "vmp_runtime.asm"
"""

    @staticmethod
    def get_variable_mapping_template():
        """Get variable mapping comment template"""
        return """; Variable mappings:
{mappings}
"""

    @staticmethod
    def get_protection_info_template():
        """Get protection information template"""
        return """; Protection Information:
; - Opcode Encryption: XorShift32
; - Code Encryption: XorShift32
; - Basic Block Seeds: Embedded
; - Anti-Debug: {anti_debug}
; - Anti-Tamper: {anti_tamper}
"""

    @staticmethod
    def format_bytecode_line(bytecode, offset, max_per_line=16):
        """Format bytecode for assembly output"""
        lines = []
        
        for i in range(0, len(bytecode), max_per_line):
            chunk = bytecode[i:i + max_per_line]
            hex_bytes = ', '.join(f'0x{b:02X}' for b in chunk)
            
            if i == 0:
                lines.append(hex_bytes)
            else:
                lines.append(f"    db {hex_bytes}")
        
        return '\n'.join(lines)
    
    @staticmethod
    def generate_vmp_assembly(bytecode, variables, config=None):
        """Generate complete VMP protected assembly"""
        config = config or {}
        
        # Format header
        header = VMPTemplates.get_vmp_header().format(
            protection_level=config.get('protection_level', 'standard'),
            timestamp=config.get('timestamp', 'N/A')
        )
        
        # Format data section
        code_bytes = VMPTemplates.format_bytecode_line(bytecode)
        
        # Variable mappings
        var_lines = []
        for name, offset in variables.items():
            var_lines.append(f";   {name:<16} equ vmp_data_seg + {offset}")
        
        variable_mappings = '\n'.join(var_lines) if var_lines else ";   (no variables)"
        
        data_section = VMPTemplates.get_data_section_template().format(
            code_bytes=code_bytes,
            code_size=len(bytecode),
            data_size=config.get('data_size', 5000),
            variable_mappings=variable_mappings
        )
        
        # Protection info
        protection_info = VMPTemplates.get_protection_info_template().format(
            anti_debug=config.get('anti_debug', 'Disabled'),
            anti_tamper=config.get('anti_tamper', 'Disabled')
        )
        
        # Combine all parts
        return header + protection_info + '\n\n' + data_section + '\n' + VMPTemplates.get_text_section_template()


class InstructionTemplates:
    """Templates for instruction conversion"""
    
    # Assembly to VMP instruction mappings
    INSTRUCTION_MAP = {
        # Data transfer
        'mov': 'STORE',
        'push': 'STORE',
        'pop': 'LOAD',
        'lea': 'GEP',
        
        # Arithmetic
        'add': 'BINOP_ADD',
        'sub': 'BINOP_SUB',
        'mul': 'BINOP_MUL',
        'imul': 'BINOP_MUL',
        'div': 'BINOP_UDIV',
        'idiv': 'BINOP_SDIV',
        
        # Logic
        'and': 'BINOP_AND',
        'or': 'BINOP_OR',
        'xor': 'BINOP_XOR',
        'shl': 'BINOP_SHL',
        'shr': 'BINOP_LSHR',
        'sar': 'BINOP_ASHR',
        
        # Comparison
        'cmp': 'CMP',
        'test': 'CMP',
        
        # Control flow
        'jmp': 'BR',
        'je': 'BR_EQ',
        'jne': 'BR_NE',
        'jg': 'BR_SGT',
        'jge': 'BR_SGE',
        'jl': 'BR_SLT',
        'jle': 'BR_SLE',
        'ja': 'BR_UGT',
        'jae': 'BR_UGE',
        'jb': 'BR_ULT',
        'jbe': 'BR_ULE',
        'call': 'CALL',
        'ret': 'RET'
    }
    
    @classmethod
    def get_vmp_instruction(cls, asm_mnemonic):
        """Get VMP instruction for assembly mnemonic"""
        return cls.INSTRUCTION_MAP.get(asm_mnemonic.lower())
    
    @staticmethod
    def is_conditional_jump(mnemonic):
        """Check if instruction is conditional jump"""
        return mnemonic.lower() in ['je', 'jne', 'jg', 'jge', 'jl', 'jle', 
                                   'ja', 'jae', 'jb', 'jbe', 'jz', 'jnz']
    
    @staticmethod
    def get_jump_condition(mnemonic):
        """Get condition predicate for jump instruction"""
        jump_conditions = {
            'je': 'EQ', 'jz': 'EQ',
            'jne': 'NE', 'jnz': 'NE',
            'jg': 'SGT',
            'jge': 'SGE',
            'jl': 'SLT',
            'jle': 'SLE',
            'ja': 'UGT',
            'jae': 'UGE',
            'jb': 'ULT',
            'jbe': 'ULE'
        }
        return jump_conditions.get(mnemonic.lower())


# Singleton instances
vmp_templates = VMPTemplates()
instruction_templates = InstructionTemplates()